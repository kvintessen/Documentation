Композиционный API предоставляет гибкий способ структурирования логики компонентов. Это альтернатива традиционному API на основе опций (`Options API`), который позволяет лучше организовать код, особенно в крупных приложениях.

#### Основные концепции Composition API

##### 1.1 **`setup()` функция**

`setup()` — это ключевая функция в композиционном API, которая вызывается перед созданием компонента. Внутри неё инициализируются реактивные данные, методы, вычисляемые свойства и другие инструменты Vue.

- **Аргументы**: `setup()` принимает два аргумента:
    1. **`props`** — свойства, переданные компоненту.
    2. **`context`** — объект, содержащий дополнительные методы (например, `attrs`, `slots`, `emit`).

Пример использования:

```TS
import { ref } from 'vue';

export default {
  props: {
    initialValue: Number
  },
  setup(props) {
    // Создаем реактивные данные
    const count = ref(props.initialValue);

    // Создаем метод для изменения состояния
    const increment = () => {
      count.value++;
    };

    // Возвращаем данные и методы, чтобы они были доступны в шаблоне
    return { count, increment };
  }
};
```

#### 1.2 **Реактивность: `ref` и `reactive`**

Композиционный API предоставляет два ключевых метода для создания реактивных данных: `ref` и `reactive`.

- **`ref`**: Создает реактивное значение. Это идеальный выбор для примитивов, таких как числа, строки, булевы значения.

Пример использования `ref`:

```TS
import { ref } from 'vue';

export default {
  setup() {
    const message = ref('Hello Vue!'); // Создание реактивного значения
    return { message };
  }
};
```

> Обратите внимание: при использовании `ref`, чтобы получить доступ к значению, нужно обращаться к свойству `.value`.

- **`reactive`**: Создает реактивный объект или массив. Это более удобный способ работы с составными данными (например, объектами и массивами).

Пример использования `reactive`:

```TS
import { reactive } from 'vue';

export default {
  setup() {
    const state = reactive({
      count: 0,
      message: 'Hello Vue!'
    });

    const increment = () => {
      state.count++;
    };

    return { state, increment };
  }
};
```

> В отличие от `ref`, доступ к свойствам реактивного объекта через `reactive` осуществляется напрямую, без `.value`.

#### 1.3 **`computed()` — Вычисляемые свойства**

`computed()` — это способ создания вычисляемых свойств, которые автоматически обновляются при изменении данных, от которых они зависят. Это помогает оптимизировать код, так как вычисления выполняются только при необходимости.

Пример:

```TS
import { ref, computed } from 'vue';

export default {
  setup() {
    const count = ref(2);

    // Вычисляемое свойство
    const doubleCount = computed(() => count.value * 2);

    return { count, doubleCount };
  }
};
```

#### 1.4 **`watch()` — Наблюдатели**

`watch()` позволяет наблюдать за изменениями реактивных данных и выполнять определённые действия при изменении этих данных. Это полезно для обработки побочных эффектов, таких как API-запросы или сохранение данных.

Пример:

```TS
import { ref, watch } from 'vue';

export default {
  setup() {
    const count = ref(0);

    // Следим за изменениями переменной count
    watch(count, (newValue, oldValue) => {
      console.log(`Значение изменилось с ${oldValue} на ${newValue}`);
    });

    return { count };
  }
};
```

#### 1.5 **`watchEffect()`**

`watchEffect()` — это альтернатива `watch()`, которая автоматически отслеживает все реактивные данные внутри переданной функции и реагирует на любые изменения. Это полезно для более простых случаев, когда не нужно явно указывать, за какими данными наблюдать.

Пример:

```TS
import { ref, watchEffect } from 'vue';

export default {
  setup() {
    const count = ref(0);
    
    // Автоматически следим за любыми изменениями реактивных данных внутри функции
    watchEffect(() => {
      console.log(`Текущее значение count: ${count.value}`);
    });

    return { count };
  }
};
```

#### 1.6 **Композиционные функции**

Одним из самых больших преимуществ Composition API является возможность создания собственных композиционных функций, которые можно использовать для повторного использования логики в разных компонентах. Эти функции позволяют изолировать бизнес-логику и отделить её от рендеринга.

Пример создания композиционной функции:

```TS
import { ref } from 'vue';

// Композиционная функция для управления счётчиком
export function useCounter() {
  const count = ref(0);

  const increment = () => {
    count.value++;
  };

  return { count, increment };
}
```

Использование в компоненте:

```TS
import { useCounter } from './useCounter';

export default {
  setup() {
    const { count, increment } = useCounter();
    return { count, increment };
  }
};
```

#### 1.7 **Контекст: `attrs`, `slots`, и `emit`**

В `setup()` можно получить доступ к дополнительным параметрам через второй аргумент — контекст.

- **`attrs`**: Доступ к атрибутам, которые не были явно определены в `props`.
- **`slots`**: Доступ к слотам компонента.
- **`emit`**: Позволяет отправлять события в родительский компонент.

Пример:

```TS
export default {
  setup(props, { attrs, slots, emit }) {
    // Используем слоты и события
    return { attrs, slots, emit };
  }
};
```

#### 1.7.1 **`attrs`** — Доступ к необработанным атрибутам

`attrs` (сокращенно от "attributes") предоставляет доступ ко всем атрибутам, которые были переданы компоненту, но не были явно определены как свойства (`props`). Это полезно для компонентов, которые передают атрибуты напрямую элементам в своём шаблоне.

##### Когда это нужно?

Представьте, что у вас есть компонент, который принимает различные атрибуты (например, классы или идентификаторы), но эти атрибуты не обязательно должны быть описаны как `props`. Тогда `attrs` позволяет передать их напрямую к вложенным элементам.

##### Пример использования:

```TS
<template>
  <button v-bind="attrs">
    {{ label }}
  </button>
</template>

<script lang="ts">
export default {
  props: {
    label: String
  },
  setup(props, { attrs }) {
    // attrs содержит все необработанные атрибуты, например, class или id
    return { attrs };
  }
};
</script>
```

Использование компонента:

```TS
<MyButton class="primary" id="submit-btn" label="Click Me" />
```

В этом примере атрибуты `class="primary"` и `id="submit-btn"` не определены в `props`, но они будут переданы через `attrs` и автоматически добавлены к элементу `<button>`.

#### 1.7.2 **`slots`** — Работа со слотами

`slots` предоставляет доступ ко всем слотам, переданным в компонент. Это используется для динамической вставки контента в компоненты, делая их более гибкими и настраиваемыми. Слоты позволяют передавать контент из родительского компонента в дочерний, при этом `slots` позволяет управлять этими данными внутри компонента.

##### Когда это нужно?

Слоты используются, когда необходимо, чтобы родительский компонент мог передать произвольный контент в дочерний компонент. Это может быть текст, HTML-разметка, другие компоненты или даже данные, переданные в слот.

##### Пример использования:

```TS
<template>
  <div>
    <!-- Отображение слота, переданного родительским компонентом -->
    <slot name="header"></slot>
    <p>Основной контент</p>
    <slot></slot> <!-- Слот по умолчанию -->
  </div>
</template>

<script lang="ts">
export default {
  setup(props, { slots }) {
    // slots содержит переданный контент
    return { slots };
  }
};
</script>
```

Использование в родительском компоненте:

```TS
<MyComponent>
  <template v-slot:header>
    <h1>Заголовок слота</h1>
  </template>
  <p>Это основной слот</p>
</MyComponent>
```

Здесь компонент `MyComponent` использует два слота:

- **Именованный слот** (`header`), в который можно передать заголовок.
- **Слот по умолчанию**, куда можно передать любой другой контент.

#### 1.7.3 **`emit`** — Отправка событий

`emit` используется для отправки событий из дочернего компонента в родительский. Это ключевой инструмент для связи между компонентами, когда дочерний компонент должен уведомить родителя о каком-либо изменении.

##### Когда это нужно?

Использование `emit` необходимо, когда компонент должен взаимодействовать с родительским компонентом, например, при изменении данных, нажатии кнопки или других действиях. Это аналог системы событий, где дочерний компонент "вызывает" событие, а родитель "слушает" это событие и обрабатывает его.

##### Пример использования:

```TS
<template>
  <button @click="handleClick">Нажми меня</button>
</template>

<script lang="ts">
export default {
  setup(props, { emit }) {
    const handleClick = () => {
      emit('button-clicked'); // Отправка события 'button-clicked' родительскому компоненту
    };

    return { handleClick };
  }
};
</script>
```

Использование в родительском компоненте:

```TS
<MyButton @button-clicked="handleButtonClick" />

<script>
export default {
  methods: {
    handleButtonClick() {
      console.log('Кнопка была нажата!');
    }
  }
};
</script>
```

В этом примере:

- В дочернем компоненте `MyButton` вызывается событие `button-clicked`, когда пользователь нажимает на кнопку.
- Родительский компонент "слушает" это событие и вызывает метод `handleButtonClick`, который выполняет какое-либо действие.
### Заключение

1. **`attrs`** позволяет работать с атрибутами, которые не были объявлены в `props` и передавать их на другие DOM-элементы.
2. **`slots`** используются для вставки динамического контента в компоненты, что делает компоненты более гибкими и настраиваемыми.
3. **`emit`** предоставляет механизм отправки событий из дочернего компонента в родительский, обеспечивая связь между ними.

Эти три возможности контекста (`attrs`, `slots`, `emit`) делают компоненты Vue ещё более гибкими, позволяя удобно управлять передачей данных, атрибутов и взаимодействием компонентов в приложении.


---

### Преимущества Composition API

- **Гибкость**: Код становится более гибким и легко расширяемым. Логику можно структурировать по функциям, что упрощает её повторное использование.
- **Масштабируемость**: В больших компонентах легче управлять сложной логикой. Вместо того чтобы добавлять больше методов и свойств в `data` или `methods`, можно просто создать новую функцию для определённой логики.
- **Легкость тестирования**: Логику компонента легче тестировать, так как она может быть изолирована в отдельные функции.

### Заключение

Композиционный API предлагает новый способ организации кода в Vue.js, предоставляя гибкие инструменты для управления состоянием, наблюдением за данными и вычислениями. Он хорошо подходит для масштабируемых приложений, где необходимо разделение логики на более мелкие, легко управляемые части.