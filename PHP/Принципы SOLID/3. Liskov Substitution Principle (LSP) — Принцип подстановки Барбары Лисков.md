
Объекты в программе должны заменяться экземплярами их подклассов без изменения правильности работы программы. Подкласс должен реализовывать все поведения базового класса.

#### Пример:

Представим, что мы разрабатываем систему управления геометрическими фигурами для графического редактора. В системе есть класс для работы с прямоугольниками, который позволяет устанавливать ширину и высоту фигуры. Понадобилось добавить поддержку квадрата, который является частным случаем прямоугольника, где ширина и высота всегда равны.

### Проблема (Нарушение LSP)

Мы создаём класс `Rectangle` и наследуем от него класс `Square`. Кажется логичным, что квадрат является прямоугольником, но здесь скрывается ошибка, нарушающая принцип LSP.

#### Реализация:

```PHP
class Rectangle {
    protected $width;
    protected $height;

    public function setWidth($width) {
        $this->width = $width;
    }

    public function setHeight($height) {
        $this->height = $height;
    }

    public function getArea() {
        return $this->width * $this->height;
    }
}

class Square extends Rectangle {
    public function setWidth($width) {
        // Для квадрата ширина = высота
        $this->width = $width;
        $this->height = $width;
    }

    public function setHeight($height) {
        // Для квадрата высота = ширина
        $this->width = $height;
        $this->height = $height;
    }
}

```

### Описание проблемы

Программа работает с фигурами и ожидает, что она может отдельно устанавливать ширину и высоту для любой фигуры. Если мы передадим квадрат как объект класса `Rectangle`, программа будет ожидать, что она может работать с ним как с обычным прямоугольником, но это не так. Например, вызов:

```PHP
$rectangle = new Square();
$rectangle->setWidth(5);
$rectangle->setHeight(10);
echo $rectangle->getArea(); // Ожидаем 5 * 10 = 50, но получаем 100
```

Здесь возникает ошибка: из-за того, что `Square` нарушает поведение прямоугольника, результат расчёта площади некорректен. Это и есть нарушение принципа LSP: квадрат не может корректно заменить прямоугольник в системе, где объекты работают с прямоугольниками.

### Решение

Чтобы решить проблему, мы должны переработать код так, чтобы класс `Square` не наследовал от `Rectangle`, а реализовывал своё поведение отдельно. Также, если мы хотим сохранить возможность использования общей логики для расчёта площади, лучше применить композицию, а не наследование.

#### Правильная реализация:

Создадим абстрактный класс для всех фигур и реализуем поведение для прямоугольника и квадрата отдельно:

```PHP
// Общий интерфейс для всех фигур
abstract class Shape {
    abstract public function getArea();
}

// Прямоугольник
class Rectangle extends Shape {
    protected $width;
    protected $height;

    public function __construct($width, $height) {
        $this->width = $width;
        $this->height = $height;
    }

    public function setWidth($width) {
        $this->width = $width;
    }

    public function setHeight($height) {
        $this->height = $height;
    }

    public function getArea() {
        return $this->width * $this->height;
    }
}

// Квадрат
class Square extends Shape {
    protected $side;

    public function __construct($side) {
        $this->side = $side;
    }

    public function setSide($side) {
        $this->side = $side;
    }

    public function getArea() {
        return $this->side * $this->side;
    }
}
```

Теперь, если программа работает с объектами классов `Rectangle` и `Square`, она точно понимает, с какой фигурой взаимодействует, и не произойдёт неожиданных изменений в поведении. Квадрат и прямоугольник теперь являются независимыми фигурами, но оба могут вычислять свою площадь через общий интерфейс `Shape`.

#### Пример использования:

```PHP
$rectangle = new Rectangle(5, 10);
echo $rectangle->getArea(); // 50

$square = new Square(5);
echo $square->getArea(); // 25
```

### Вывод

Принцип подстановки Лисков (LSP) гласит, что подклассы должны корректно заменять свои базовые классы без нарушения работы программы. В нашем случае использование наследования для квадрата от прямоугольника нарушило этот принцип, так как квадрат не ведёт себя так же, как прямоугольник. Решением стало разделение логики для прямоугольника и квадрата, что делает код более предсказуемым и соответствует принципу LSP.