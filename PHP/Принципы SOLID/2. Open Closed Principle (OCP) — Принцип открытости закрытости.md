Принцип **открытости/закрытости (Open/Closed Principle, OCP)** гласит, что классы должны быть **открыты для расширения**, но **закрыты для модификации**. Это означает, что мы можем добавлять новое поведение в класс, не изменяя его существующий код.

### Пример задачи:

Представим, что у нас есть система для расчета стоимости заказов. Изначально поддерживаются только заказы с фиксированной стоимостью, но через некоторое время требуется добавить возможность расчета скидки для специальных типов заказов, например, скидка для постоянных клиентов.

### Нарушение OCP:

Если бы мы не соблюдали принцип OCP, мы могли бы сделать следующее:

#### Пример:

```PHP
class Order {
    private $price;

    public function __construct($price) {
        $this->price = $price;
    }

    public function calculateTotal($customerType) {
        if ($customerType == 'regular') {
            return $this->price;
        } elseif ($customerType == 'vip') {
            return $this->price * 0.9; // 10% скидка для VIP клиентов
        } else {
            return $this->price;
        }
    }
}
```

### Проблема:

В таком коде, если появится новый тип клиента, например, "студент" с особой скидкой, нам придётся изменять метод `calculateTotal` в классе `Order`. Это нарушение принципа OCP, так как для добавления нового типа скидки мы вынуждены модифицировать существующий класс. В будущем, если потребуется добавить больше типов клиентов, код станет сложным и запутанным.

### Решение с соблюдением OCP:

Чтобы соблюдать принцип открытости/закрытости, мы можем использовать полиморфизм или шаблон проектирования «Стратегия». Это позволит нам добавлять новое поведение (например, скидки) без изменения кода самого класса заказа.

#### Правильная реализация:

1. Создадим интерфейс для расчета скидок.
2. Для каждого типа скидки реализуем отдельный класс.
3. Добавим возможность "внедрять" нужный тип скидки в класс `Order`, не изменяя его код.


```PHP
// Интерфейс для стратегии расчета скидки
interface DiscountStrategy {
    public function applyDiscount($price);
}

// Стратегия для обычного клиента без скидки
class NoDiscount implements DiscountStrategy {
    public function applyDiscount($price) {
        return $price;
    }
}

// Стратегия для VIP-клиентов
class VipDiscount implements DiscountStrategy {
    public function applyDiscount($price) {
        return $price * 0.9; // 10% скидка
    }
}

// Стратегия для студентов
class StudentDiscount implements DiscountStrategy {
    public function applyDiscount($price) {
        return $price * 0.85; // 15% скидка
    }
}

// Класс заказа, который использует стратегию для расчета скидки
class Order {
    private $price;
    private $discountStrategy;

    public function __construct($price, DiscountStrategy $discountStrategy) {
        $this->price = $price;
        $this->discountStrategy = $discountStrategy;
    }

    public function calculateTotal() {
        return $this->discountStrategy->applyDiscount($this->price);
    }
}
```

Пример использования:

```PHP
// Обычный заказ без скидки
$order1 = new Order(1000, new NoDiscount());
echo $order1->calculateTotal(); // 1000

// Заказ с VIP-скидкой
$order2 = new Order(1000, new VipDiscount());
echo $order2->calculateTotal(); // 900

// Заказ со студенческой скидкой
$order3 = new Order(1000, new StudentDiscount());
echo $order3->calculateTotal(); // 850
```

### Преимущества соблюдения OCP:

1. **Расширение без модификации**: Если потребуется добавить новый тип скидки, мы просто создадим новый класс, реализующий интерфейс `DiscountStrategy`, и передадим его в конструктор класса `Order`. Класс `Order` не изменяется, что соответствует принципу открытости/закрытости.
    
2. **Поддерживаемость**: Код легко расширять, тестировать и поддерживать, так как новые типы скидок добавляются независимо от существующих классов.
    

### Вывод:

Принцип открытости/закрытости позволяет легко расширять систему, не изменяя существующий код. Это предотвращает ошибки, которые могут возникнуть при изменении работающего кода, и делает систему более гибкой для будущих изменений.