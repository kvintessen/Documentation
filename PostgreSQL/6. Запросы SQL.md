**Запросы SQL** — это ключевая часть работы с базами данных. С их помощью можно извлекать, добавлять, обновлять и удалять данные в таблицах базы данных. В проектировании базы данных важно понимать основные типы запросов, которые помогут эффективно управлять данными.

### Основные типы SQL-запросов:

#### 1. **SELECT (выборка данных)**

`SELECT` используется для извлечения данных из одной или нескольких таблиц. Это один из наиболее часто используемых запросов в SQL.

```SQL
SELECT name, email FROM users;
```

Этот запрос выбирает имена и email из таблицы `users`.

- **WHERE** — фильтрует строки по определенным условиям:
```SQL
SELECT * FROM users WHERE age > 18;
```
- **ORDER BY** — сортирует результат по одному или нескольким столбцам:
```SQL
SELECT * FROM users ORDER BY name ASC;
```
- **LIMIT** — ограничивает количество возвращаемых строк:
```SQL
SELECT * FROM users LIMIT 10;
```
- **GROUP BY** — группирует строки с одинаковыми значениями в столбце:
```SQL
SELECT country, COUNT(*) FROM users GROUP BY country;
```
- **HAVING** — фильтрует строки после применения `GROUP BY`:
```SQL
SELECT country, COUNT(*) FROM users GROUP BY country HAVING COUNT(*) > 5;
```
#### 2. **INSERT (вставка данных)**

`INSERT` используется для добавления новых строк в таблицу.

**Пример:**
```SQL
INSERT INTO users (name, email, age) VALUES ('John', 'john@example.com', 25);
```

Этот запрос вставляет новую запись в таблицу `users` с именем "John", email и возрастом 25.

#### 3. **UPDATE (обновление данных)**

`UPDATE` используется для изменения существующих данных в таблице.

**Пример:**
```SQL
UPDATE users SET email = 'newemail@example.com' WHERE id = 1;
```

Этот запрос обновляет email для пользователя с `id = 1`.

- **SET** — определяет, какие столбцы нужно изменить.
- **WHERE** — указывает, какие строки следует обновить. Если не указать `WHERE`, обновятся все строки.

#### 4. **DELETE (удаление данных)**

`DELETE` используется для удаления данных из таблицы.

**Пример:**
```SQL
DELETE FROM users WHERE id = 1;
```

Этот запрос удаляет запись пользователя с `id = 1`.

- **Где важно:** Если не указать `WHERE`, все строки в таблице будут удалены, поэтому с `DELETE` нужно быть осторожным.

#### 5. **JOIN (объединение таблиц)**

`JOIN` используется для объединения данных из нескольких таблиц, основываясь на отношениях между ними.

- **INNER JOIN** — возвращает только те строки, которые имеют совпадение в обеих таблицах:
```SQL
SELECT users.name, orders.order_date 
FROM users 
INNER JOIN orders ON users.id = orders.user_id;
```

- **LEFT JOIN (LEFT OUTER JOIN)** — возвращает все строки из левой таблицы и совпадающие строки из правой таблицы. Если совпадений нет, будут возвращены `NULL` для правой таблицы:
```SQL
SELECT users.name, orders.order_date 
FROM users 
LEFT JOIN orders ON users.id = orders.user_id;
```

- **RIGHT JOIN (RIGHT OUTER JOIN)** — возвращает все строки из правой таблицы и совпадающие строки из левой таблицы.
**Пример:**
```SQL
SELECT users.name, orders.order_date 
FROM users 
RIGHT JOIN orders ON users.id = orders.user_id;
```

- **FULL JOIN (FULL OUTER JOIN)** — Возвращает все строки, когда есть совпадения либо в левой, либо в правой таблице. Если в одной из таблиц отсутствуют совпадения, возвращаются `NULL` для столбцов этой таблицы. Этот тип объединения включает результат как `LEFT JOIN`, так и `RIGHT JOIN`.

**Пример:**
```SQL
SELECT users.name, orders.order_date 
FROM users 
FULL JOIN orders ON users.id = orders.user_id;
```

- **CROSS JOIN** —  Возвращает декартово произведение двух таблиц, то есть каждая строка первой таблицы объединяется со всеми строками второй таблицы. Чаще всего используется в редких случаях, так как может возвращать огромное количество строк.

**Пример:**
```SQL
SELECT users.name, orders.order_date 
FROM users 
CROSS JOIN orders;
```
В результате получится комбинация всех пользователей с каждым заказом.

- **SELF JOIN** - Это особый случай объединения, когда таблица объединяется сама с собой. Это полезно, например, для нахождения отношений между записями в одной таблице.

**Пример:** Предположим, у нас есть таблица сотрудников, где каждый сотрудник может иметь руководителя. Мы можем использовать self-join, чтобы найти всех сотрудников и их руководителей.

```SQL
SELECT e1.name AS Employee, e2.name AS Manager 
FROM employees e1 
LEFT JOIN employees e2 ON e1.manager_id = e2.id;
```

- **NATURAL JOIN** - Этот тип объединения автоматически объединяет две таблицы по столбцам с одинаковыми именами и типами данных. Однако он используется реже, так как делает все автоматически и не всегда дает предсказуемые результаты.

**Пример:**
```SQL
SELECT * 
FROM users 
NATURAL JOIN orders;
```

Этот запрос объединит `users` и `orders` по столбцам с одинаковыми именами.

### Резюме:

- **INNER JOIN** — возвращает только совпадающие строки.
- **LEFT JOIN** — возвращает все строки из левой таблицы, даже если нет совпадений.
- **RIGHT JOIN** — возвращает все строки из правой таблицы, даже если нет совпадений.
- **FULL JOIN** — возвращает все строки, независимо от наличия совпадений.
- **CROSS JOIN** — возвращает декартово произведение двух таблиц.
- **SELF JOIN** — объединяет таблицу саму с собой.
- **NATURAL JOIN** — объединяет таблицы по столбцам с одинаковыми именами.

Каждый тип объединения используется в зависимости от того, как именно нужно связать данные из двух или более таблиц.


**LATERAL JOIN** — это специальный тип соединения в SQL, который позволяет использовать данные из предыдущих таблиц в запросе внутри подзапроса. В PostgreSQL (и других СУБД, поддерживающих этот тип соединения) `LATERAL` используется для выполнения подзапросов, которые могут ссылаться на каждую строку внешней таблицы, что дает возможность более гибкого и динамичного использования подзапросов.

### Зачем нужен `LATERAL JOIN`?

Обычно подзапросы не могут ссылаться на данные из внешнего запроса (запроса, который их вызывает). Однако `LATERAL` разрешает подзапросам ссылаться на колонки предыдущей таблицы в запросе, создавая возможность для более сложных и гибких операций с данными. Это особенно полезно для случаев, когда необходимо выполнить подзапрос для каждой строки внешней таблицы.

### Как работает `LATERAL JOIN`?

Подзапрос с ключевым словом `LATERAL` выполняется для каждой строки внешней таблицы, и его результат добавляется в результат запроса.

### Пример:

Допустим, у нас есть две таблицы:

- **users** — содержит информацию о пользователях.
- **orders** — содержит заказы пользователей, и каждый пользователь может иметь несколько заказов.

Если мы хотим получить последние заказы для каждого пользователя, можно использовать `LATERAL JOIN`:

```SQL
SELECT u.name, o.order_id, o.amount
FROM users u
LEFT JOIN LATERAL (
    SELECT order_id, amount
    FROM orders
    WHERE orders.user_id = u.id
    ORDER BY order_date DESC
    LIMIT 1
) o ON true;
```

### Что происходит в этом запросе:

1. Таблица `users` (`u`) идет первой и для каждой её строки выполняется подзапрос.
2. Подзапрос в `LATERAL JOIN` выбирает последний заказ (`LIMIT 1`) для каждого пользователя (`u.id`).
3. Запрос возвращает имя пользователя и его последний заказ с суммой заказа.

### Особенности `LATERAL JOIN`:

1. **Динамический доступ к данным из внешней таблицы**:
    
    - Внутренний подзапрос может ссылаться на каждую строку внешней таблицы (в нашем примере — `users`), что делает его очень гибким и удобным для сложных запросов.
2. **Сокращение дублирования логики**:
    
    - Вместо того чтобы писать несколько отдельных запросов для разных строк внешней таблицы, `LATERAL JOIN` позволяет выполнять подзапрос для каждой строки "на месте".
3. **Комбинация с другими типами соединений**:
    
    - `LATERAL` можно использовать с любыми другими типами соединений, например, `LEFT JOIN LATERAL`, `INNER JOIN LATERAL`, чтобы определить, как именно будут связаны таблицы.

### Когда полезен `LATERAL JOIN`?

- Когда необходимо выполнить подзапрос для каждой строки внешней таблицы, с доступом к данным этой строки.
- Для работы с данными, которые динамически изменяются в зависимости от внешних таблиц (например, последние записи, агрегированные данные и т.д.).
- Когда нужно оптимизировать сложные запросы с несколькими подзапросами.

### Другой пример:

Допустим, у нас есть таблица с клиентами и таблица с транзакциями. Мы хотим получить для каждого клиента его три самые большие транзакции.

```SQL
SELECT c.client_name, t.transaction_id, t.amount
FROM clients c
	JOIN LATERAL (
	    SELECT transaction_id, amount
	    FROM transactions
	    WHERE transactions.client_id = c.client_id
	    ORDER BY amount DESC
	    LIMIT 3
	) t ON true;
```

тот запрос возвращает по три самые большие транзакции для каждого клиента.
### Заключение:

`LATERAL JOIN` — это мощный инструмент для выполнения подзапросов, которые зависят от данных внешней таблицы. Он предоставляет большую гибкость и может использоваться для более сложных операций с данными, таких как извлечение последних записей, динамическое объединение и работа с подмножествами данных.

#### 6. **Агрегатные функции**

Агрегатные функции позволяют выполнять вычисления над несколькими строками и возвращать одно значение:

- **COUNT()** — возвращает количество строк:
```SQL
SELECT COUNT(*) FROM users;
```

- **SUM()** — возвращает сумму значений:
```SQL
SELECT SUM(amount) FROM orders;
```

- **AVG()** — возвращает среднее значение:
```SQL
SELECT AVG(age) FROM users;
```

- **MAX() и MIN()** — возвращают максимальное и минимальное значение:
```SQL
SELECT MAX(age) FROM users;
```

#### 7. **Подзапросы (Subqueries)**

Подзапросы позволяют вложить один запрос в другой. Это полезно, когда необходимо выполнить один запрос на основе результата другого.

**Пример:**
```SQL
SELECT * FROM users WHERE id IN (SELECT user_id FROM orders WHERE amount > 100);
```

Этот запрос возвращает всех пользователей, которые сделали заказы на сумму более 100.

#### 8. **Операторы `LIKE` и `BETWEEN`**

- **LIKE** используется для поиска шаблонов в строках:
```SQL
SELECT * FROM users WHERE name LIKE 'J%';
```
 
 Этот запрос находит всех пользователей, чьи имена начинаются с буквы "J".

- **BETWEEN** используется для поиска значений в определенном диапазоне:
```SQL
SELECT * FROM orders WHERE amount BETWEEN 100 AND 500;
```

#### 9. **Транзакции**

Транзакции позволяют сгруппировать несколько SQL-запросов в одну логическую операцию, которая должна быть выполнена полностью или не выполнена вовсе. Это полезно для обеспечения целостности данных.

**Пример:**
```SQL
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;
```

Если в процессе выполнения транзакции произойдет ошибка, можно сделать `ROLLBACK`, чтобы отменить все изменения.

---

### Итог:

Запросы SQL — это основной способ взаимодействия с базами данных. Важно освоить базовые команды, такие как `SELECT`, `INSERT`, `UPDATE`, `DELETE`, а также более продвинутые возможности, такие как соединения таблиц с помощью `JOIN`, группировка с использованием агрегатных функций и работа с подзапросами. Понимание того, как эти запросы работают, поможет эффективно управлять данными и строить сложные запросы для получения нужной информации.